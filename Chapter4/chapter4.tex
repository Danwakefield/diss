\chapter{Testing}

%Detailed descriptions of every test case are definitely not what is required here. What is important is to show that you adopted a sensible strategy that was, in principle, capable of testing the system adequately even if you did not have the time to test the system fully.

%Have you tested your system on "real users"? For example, if your system is supposed to solve a problem for a business, then it would be appropriate to present your approach to involve the users in the testing process and to record the results that you obtained. Depending on the level of detail, it is likely that you would put any detailed results in an appendix.

%the following sections indicate some areas you might include. Other sections may be more appropriate to your project. 

\section{Overall Approach to Testing}
This project took a detailed approach to testing due to the development process including TDD from the start and evolving into FDD when a more concrete product appeared.
This paid off multiple times catching bugs and regressions that occurred. 

TDD was used thoughout but switched from focussing on unit tests to integration tests
TDD was used for small components throughout development though not to the degree of completeness that was desired.

Integration testing was the main form of testing throughout as constructing an AST by hand for even a simple if statement is much hander than proving it works by running one.


\subsection{Unit Tests}
The unit tests for my code leveraged Go's builtin testing package and the idiom of table driven tests.
Providing a list of inputs and expected outputs for each function is generally more than enough to prove it works.

I created unit tests for most of the code in this project.
This was done using Go's built in testing package which follows the philosophy that no output is a good sign. 
The only time something is printed is after calling one of the methods to indicate failure of a test.

Almost all unit tests in the Go ecosystem are written using a table driven approach and while other languages could do the same many dont take advantage of the simplicity of them.
These are looped over and tested in turn.
It may sound simplistic but for black box testing this is a very 

\section{Automated Testing}
Towards the end of the project I started using a continuous integration service called drone.io\footnote{My project's public page is available at \url{https://drone.io/github.com/Danwakefield/gosh}}.
Every time a commit was pushed to the github repository it would clone the code and run the both the unit and integration tests against the changes.
A notification email was sent if a build failed.

The system just ran the normal unit and integration tests however since this codebase can issue system calls it is safer to run these tests in a disposable container in case of a severe bug.  
CI systems also make it easy for contributors to see the status of the code and ensure that pull requests will not cause any regression.

\section{Integration Testing}
Integration testing 

\section{User Testing}
















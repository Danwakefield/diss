\chapter{Implementation}

%The implementation should look at any issues you encountered as you tried to implement your design. During the work, you might have found that elements of your design were unnecessary or overly complex; perhaps third party libraries were available that simplified some of the functions that you intended to implement. If things were easier in some areas, then how did you adapt your project to take account of your findings?

%It is more likely that things were more complex than you first thought. In particular, were there any problems or difficulties that you found during implementation that you had to address? Did such problems simply delay you or were they more significant? 

%You can conclude this section by reviewing the end of the implementation stage against the planned requirements. 

\section{Arithmetic}
The arithmetic construct was the first thing I created.
It is a standalone piece of code only exposing a single method, Parse, which takes a string representing an equation and returning the integer value it evaluates too or an error.
Because of this isolation I created it as a sub package which also allowed me to simplify the error handling.
I was able to panic and recover\footnote{Panic is similar to an exception in other languages but has different semantics. Errors in Go should be passed through the use of multiple return values instead.} to completely unwind the parser and lexer.
Although panics are reserved for truly exceptional cases in Go, they had to be used in this case.
Errors encountered during lexing or parsing of a language are almost always fatal as they leave the system in an indeterminate state.
For example, the following make no sense in the context of a mathematical equation:
\begin{verbatim}
++
  or
35 67 89
\end{verbatim}
This is an implementation detail and can of course be treated differently.
In bash the '++' symbol has a meaning, it can represent post-increment or pre-increment depending on its position.
The numbers could also be joined together into a single literal; Python and Java do something similar with underscores rather than spaces\cite{UNDERSCORE-NUM-LITERAL}.

Another of Go's golden rules is never to raise a panic across package boundaries and to do this we defer a recover function.
If recover detects we have panicked it checks to see if it should be returned as an error instead.
Unfortunately during testing I discovered that the checks where not through enough and allowed division by zero errors to bubble up crashing the whole program. 
The fix for this would be quite simple, it just requires the addition of a division helper function similar to that used for shifting (See \ref{lst:arith-shift}). XXX % Add reference to integration test that caught it.
\newpage %XXX NEWPAGE 
\subsection{Lexer}
The Lexer was completed during the first iteration.
The syntax for an equation is quite simple, consisting of just:
\begin{itemize*}
	\item Variable Names
    \item Symbols
	\item Numeric Literals
\end{itemize*}

Variable names are detected using the following simple regular expression, \verb![a-zA-Z_][a-zA-Z0-9_]*!.

POSIX requires that detection of numeric values can be done in base 10 (Decimal, 8 (Octal) and 16 (Hexadecimal).
Whatever type is detected it is converted to base 10 inside the lexer.
If the literal is invalid, e.g \verb!0xffk! an error is returned that unwinds the parse.
With the current design if assignments have been applied before the error they would remain in effect, see~\ref{sec:scope}.

Symbols are the simplest thing to detect, as the code in~\ref{lst:arith-symbol-lex} shows.
Simple lookaheads are that is needed.

\subsection{Parser}
The parser was not completed along with the lexer in the first iteration as had been planned.
It was finished in the second one along with extensions to Scope.

The tokens passed from the lexer are assigned to their node type by a simple switch statement.
There 

\subsection{Variables}
Special variables access

\subsection{Ternary Bug}

\section{Scope}
\label{sec:scope}

\subsection{Variables}
\subsection{User Functions}
\subsection{Aliases}

\section{Main Lexer}

\subsection{Strings}
\subsection{Variables}
\subsection{Subshells}
\subsection{Arithmetic}

\section{Main Parser, AST \& Nodes}

\subsection{Simple Command}
\subsection{Command}
\subsection{Pipeline}
\subsection{And Or}
\subsection{List}

\section{Expansion}

\subsection{Tilde}
\subsection{Substitutions}
\subsection{Globbing}
\subsection{Word Splitting}

\section{Builtin Commands}

\section{Circular Imports}





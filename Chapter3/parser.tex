\section{Main Parser, AST \& Nodes}
The parser turns the tokens into nodes and constructs AST's with them.
It was developed iteratively as other elements of the code where completed. XXX

\subsection{Simple Command}
A simple command is a line that contains a command with optional arguments and variable assignments.
The command can be a builtin (See~\ref{sec:builtins}), a function (See~\ref{sec:user-functions}) or an external command.

If the line with assignments also has an external command call, the assignments are temporary and are removed when the command completes.

During the third iteration this was created to support commands with arguments.
It was expanded during the fourth to accommodate variables assignments and during the fifth, for arguments that contained substitutions.
The simple command function is also the place that function definitions are detected and this was added during the penultimate iteration.

\subsection{Command}
Command is the function that parses the command structures of the code.
This includes the 'if', 'for', 'until', 'while' and 'case' expressions.
The code for parsing these is separated from the main functions as the logic can be many lines long.
The longest functionin the codebase is the parsing routine for a case statement at over 

It also the place that command grouping occurs.
This feature is often seen when defining shell functions and some people may believe that, like other languages, it is a part of their definition syntax.
It is not however and can be used anywhere a command can including in a pipeline or in a conditional to avoid certain bugs.
A command group begins with a '\{' and ends with a corresponding '\}'.
Anything contained between the two is parsed as a separate group which allows redirections to be applied to everything it contains.
See the code in~\ref{lst:command-grouping} for examples.

\subsection{Pipeline}
The pipe
\subsection{And Or}
\subsection{List}

